'''
Задача-1: Реализовать индексацию элементов списка не с нуля, а с 5, т.е. 5, 6, 7
и т.д.
'''

class MyList(list):
    def __getitem__(self, offset):
        return super().__getitem__(offset - 5)

x = MyList('abcdefghijklmn')
y = MyList([0,1,2,3,4,5,6,7,8,9,10])
print(x[5])
print(y[6])


'''
Задача-2: Придумать любу структуру данных. Она должна содержать два атрибута.
Значение одного атрибута передается в конструктор, а значение другого - определяетсяъ
прямо в конструкторе класса. Для этой структуры данных написать метод,
который должен выполнять какой-то функционал. Создать экземпляр класса, передать
данные. Вызывать метод. Проверить, что находится в переменной-экземпляре класса.
Переопределить метод __str__. Этот метод должен возвращать тот результат,
который вы захотите. Проверить еще раз. В комментарии написать, в чем разница
между подходом с использованием метода __str__ и без него.


# До переопределения метода __str__() вывод объекта на печать выдавал нечто подобное: <__main__.Power2 object at 0x03712DB0>
# после переопределения, преобразование объекта в строy = MyList([0,1,2,3,4,5,6,7,8,9,10])ку стало происходить по нашим правилам


Задача-3: Продолжить работу над задачей 2. Добавить еще один метод. Он должен
вызваться из экземпляра класса. В этот метод нужно передать некое значение.
Сам метод должен ловить значение и что-то с ним делать и возвращать результат.
Реализовать для этого метода декоратор @staticmethod
'''

class MyTest:
    def __init__(self, key):
        self.key = key
        self.value = 2**key

    def change_key(self, key):
        self.key = key
        self.value = 2**key

    def __str__(self):
        return "key: {}; value: {}".format(self.key, self.value)

    @staticmethod
    def just_calc_power(key):
        return 2**key

variable = MyTest(4)
variable.change_key(3)
print(variable)

print(MyTest.just_calc_power(5))